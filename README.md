---
# this app supports the persistence lecture in CSD214 
## JPA Product Management Console Application

This project is a simple Java console application designed to demonstrate the fundamentals of the **Java Persistence API (JPA)** for database persistence. It serves as a practical example of converting a raw JDBC application into a more modern, maintainable application using an Object-Relational Mapping (ORM) framework.

The application connects to a MySQL database to perform basic CRUD (Create, Read, Update) operations on a `Product` entity.

## Features

-   **Database Interaction via JPA:** All database operations are handled through the standard JPA `EntityManager`.
-   **Automatic Schema Generation:** Hibernate automatically creates the database schema (`Product` table) on application startup.
-   **CRUD Operations:**
    -   **Create:** Populates the database with a predefined list of products.
    -   **Read:** Queries and displays all products from the database.
    -   **Update:** Finds a specific product by its ID and updates its price to demonstrate automatic dirty checking.
-   **Externalized Configuration:** Database connection details are managed in the `persistence.xml` file, separate from the application code.

## Technology Stack

-   **Java:** Core programming language (written for Java 11+)
-   **JPA (Jakarta Persistence API):** The standard specification for ORM in Java.
-   **Hibernate:** The JPA implementation provider used to manage the object-relational mapping.
-   **MySQL:** The relational database used for persistence.
-   **MySQL Connector/J:** The JDBC driver that Hibernate uses under the hood to communicate with the database.
-   **Maven:** Project build and dependency management.
-   **Docker:** For running a consistent and isolated MySQL database environment.

## Prerequisites

Before you begin, ensure you have the following installed on your system:

-   **Java Development Kit (JDK):** Version 11 or higher.
-   **Apache Maven:** To build the project and manage dependencies.
-   **Docker and Docker Compose:** To easily run the required MySQL database.
-   **An IDE:** IntelliJ IDEA, Eclipse, or VS Code with Java support is recommended.

## Setup and Running Instructions

Follow these steps to get the application running.

### 1. Clone the Repository

Clone this project to your local machine:
```bash
git clone <your-repository-url>
cd <your-project-directory>
```

### 2. Start the Database with Docker

A `docker-compose.yml` file is provided to simplify the database setup. This will start a MySQL 8 container with the correct database and user pre-configured.

From the root of the project directory, run:
```bash
docker-compose up -d
```
This command will:
-   Pull the `mysql:8.0` image if you don't have it.
-   Start a MySQL container in the background (`-d`).
-   Create a database named `csd214-lab0` and a user `csd214`.
-   Map port `3333` on your local machine to port `3306` in the container.

You can verify the container is running with `docker ps`.

### 3. Verify `persistence.xml` Configuration

Make sure your JPA configuration matches the database environment set up by Docker. Open the configuration file at `src/main/resources/META-INF/persistence.xml`.

The key properties should match the values in `docker-compose.yml`:
```xml
<!-- Ensure these properties match your Docker setup -->
<property name="jakarta.persistence.jdbc.url" value="jdbc:mysql://localhost:3333/csd214-lab0?createDatabaseIfNotExist=true"/>
<property name="jakarta.persistence.jdbc.user" value="csd214"/>
<property name="jakarta.persistence.jdbc.password" value="itstudies1245"/>
```
*(Note: If you have modified the `persistence.xml` to use different credentials like `root` or another database name, ensure your `docker-compose.yml` is updated to match, or vice-versa.)*

### 4. Build the Project

Use Maven to compile the code and download all the required dependencies.
```bash
mvn clean install
```
This will produce a JAR file in the `target/` directory.

### 5. Run the Application

You can run the application directly from your IDE or from the command line.

**From your IDE:**
-   Open the project.
-   Locate the `Main.java` file.
-   Right-click and select "Run 'Main.main()'".

**From the Command Line:**
-   Execute the `main` method using the compiled classes.
```bash
# This command assumes you are in the project's root directory
java -cp target/classes:$(mvn dependency:build-classpath | grep -v 'INFO') org.csd211.productApp.Main
```

You should see output in the console showing the SQL generated by Hibernate, followed by the list of products before and after the update operation.

## Project Structure

```
.
├── docker-compose.yml      # Docker configuration for the MySQL database
├── pom.xml                 # Maven project configuration and dependencies
└── src
    ├── main
    │   ├── java
    │   │   └── org/csd211/productApp
    │   │       ├── App.java        # Contains the core application logic (JPA operations)
    │   │       ├── Main.java       # The main entry point of the application
    │   │       └── Product.java    # The JPA @Entity class
    │   └── resources
    │       └── META-INF
    │           └── persistence.xml # JPA configuration (database connection, provider)
    └── test```

## Key JPA Concepts Demonstrated

-   **`@Entity` Annotation:** The `Product.java` class is marked as `@Entity` to map it to a database table.
-   **`@Id` and `@GeneratedValue`:** These annotations are used to define the primary key and specify its generation strategy.
-   **`EntityManager` & `EntityManagerFactory`:** The core of JPA. The `App.java` class uses these to manage entity lifecycles and transactions.
-   **Transactions:** All database write operations (`persist`, `update`) are wrapped in transactions using `EntityTransaction`.
-   **JPQL (Java Persistence Query Language):** The `viewProducts` method uses an object-oriented JPQL query (`SELECT p FROM Product p`) to retrieve data.
-   **Automatic Dirty Checking:** The `updateProduct` method demonstrates how JPA automatically detects changes to a managed entity and writes an `UPDATE` statement to the database upon transaction commit.
